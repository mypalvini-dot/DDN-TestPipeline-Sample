#!/usr/bin/env python3
"""
SAN Storage Automation Base Script
Template for RAID creation, volume management, and performance testing
"""

import argparse
import json
import logging
import os
import sys
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import paramiko
import requests

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('san_automation.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class Config:
    """Configuration data class"""
    san_ip: str
    host_ip: str
    san_username: str
    san_password: str
    host_username: str
    host_password: str
    raid_level: str = "5"
    volume_size_gb: int = 100
    volume_name: str = "test_volume"
    mount_point: str = "/mnt/san_volume"
    test_duration: int = 300

class BaseSanManager:
    """Base class for SAN storage management"""
    
    def __init__(self, config: Config):
        self.config = config
        self.connected = False
    
    def connect(self) -> bool:
        """Connect to SAN device"""
        raise NotImplementedError("Subclasses must implement connect method")
    
    def disconnect(self) -> bool:
        """Disconnect from SAN device"""
        raise NotImplementedError("Subclasses must implement disconnect method")
    
    def get_disks(self) -> Optional[List[Dict]]:
        """Get available disks"""
        raise NotImplementedError("Subclasses must implement get_disks method")
    
    def create_raid(self, disk_ids: List[str], raid_level: str) -> Optional[str]:
        """Create RAID array"""
        raise NotImplementedError("Subclasses must implement create_raid method")
    
    def create_volume(self, array_id: str, name: str, size_gb: int) -> Optional[str]:
        """Create volume on RAID array"""
        raise NotImplementedError("Subclasses must implement create_volume method")
    
    def map_volume_to_host(self, volume_id: str, host_identifier: str) -> bool:
        """Map volume to host"""
        raise NotImplementedError("Subclasses must implement map_volume_to_host method")
    
    def wait_for_operation(self, operation_id: str, timeout: int = 300) -> bool:
        """Wait for async operation to complete"""
        raise NotImplementedError("Subclasses must implement wait_for_operation method")

class BaseHostManager:
    """Base class for host management"""
    
    def __init__(self, config: Config):
        self.config = config
        self.ssh_client = None
        self.connected = False
    
    def connect(self) -> bool:
        """Connect to host via SSH"""
        try:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh_client.connect(
                self.config.host_ip,
                username=self.config.host_username,
                password=self.config.host_password,
                timeout=30
            )
            self.connected = True
            logger.info(f"Connected to host: {self.config.host_ip}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to host: {e}")
            return False
    
    def disconnect(self) -> bool:
        """Disconnect from host"""
        if self.ssh_client:
            self.ssh_client.close()
            self.connected = False
            logger.info("Disconnected from host")
        return True
    
    def execute_command(self, command: str, timeout: int = 30) -> Dict[str, Any]:
        """Execute command on host and return results"""
        try:
            stdin, stdout, stderr = self.ssh_client.exec_command(command, timeout=timeout)
            return {
                "stdout": stdout.read().decode().strip(),
                "stderr": stderr.read().decode().strip(),
                "exit_code": stdout.channel.recv_exit_status()
            }
        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            return {"stdout": "", "stderr": str(e), "exit_code": -1}
    
    def rescan_storage(self) -> bool:
        """Rescan storage devices"""
        raise NotImplementedError("Subclasses must implement rescan_storage method")
    
    def detect_new_device(self) -> Optional[str]:
        """Detect new storage device"""
        raise NotImplementedError("Subclasses must implement detect_new_device method")
    
    def format_device(self, device: str, filesystem: str = "ext4") -> bool:
        """Format storage device"""
        raise NotImplementedError("Subclasses must implement format_device method")
    
    def mount_device(self, device: str, mount_point: str) -> bool:
        """Mount storage device"""
        raise NotImplementedError("Subclasses must implement mount_device method")
    
    def run_performance_test(self, mount_point: str, duration: int) -> bool:
        """Run storage performance test"""
        raise NotImplementedError("Subclasses must implement run_performance_test method")

class SanAutomationOrchestrator:
    """Orchestrator class to manage the entire automation process"""
    
    def __init__(self, san_manager: BaseSanManager, host_manager: BaseHostManager):
        self.san_manager = san_manager
        self.host_manager = host_manager
        self.operation_status = {
            "san_connection": False,
            "host_connection": False,
            "raid_created": False,
            "volume_created": False,
            "volume_mapped": False,
            "volume_mounted": False,
            "test_completed": False
        }
    
    def initialize_connections(self) -> bool:
        """Initialize connections to SAN and host"""
        logger.info("Initializing connections...")
        
        # Connect to SAN
        if self.san_manager.connect():
            self.operation_status["san_connection"] = True
            logger.info("SAN connection established")
        else:
            logger.error("Failed to connect to SAN")
            return False
        
        # Connect to host
        if self.host_manager.connect():
            self.operation_status["host_connection"] = True
            logger.info("Host connection established")
        else:
            logger.error("Failed to connect to host")
            return False
        
        return True
    
    def create_storage_infrastructure(self) -> bool:
        """Create RAID, volume, and map to host"""
        logger.info("Creating storage infrastructure...")
        
        # Get available disks
        disks = self.san_manager.get_disks()
        if not disks:
            logger.error("No disks available")
            return False
        
        # Select disks for RAID (first 3 for RAID 5)
        disk_ids = [disk['id'] for disk in disks[:3]]
        logger.info(f"Selected disks for RAID {self.san_manager.config.raid_level}: {disk_ids}")
        
        # Create RAID
        array_id = self.san_manager.create_raid(disk_ids, self.san_manager.config.raid_level)
        if not array_id:
            logger.error("Failed to create RAID array")
            return False
        self.operation_status["raid_created"] = True
        
        # Wait for RAID initialization
        logger.info("Waiting for RAID initialization...")
        time.sleep(30)
        
        # Create volume
        volume_id = self.san_manager.create_volume(
            array_id, 
            self.san_manager.config.volume_name, 
            self.san_manager.config.volume_size_gb
        )
        if not volume_id:
            logger.error("Failed to create volume")
            return False
        self.operation_status["volume_created"] = True
        
        # Map volume to host
        if self.san_manager.map_volume_to_host(volume_id, self.host_manager.config.host_ip):
            self.operation_status["volume_mapped"] = True
            logger.info("Volume mapped to host successfully")
        else:
            logger.error("Failed to map volume to host")
            return False
        
        return True
    
    def configure_host_storage(self) -> bool:
        """Configure storage on host"""
        logger.info("Configuring host storage...")
        
        # Rescan storage
        if not self.host_manager.rescan_storage():
            logger.error("Failed to rescan storage")
            return False
        
        # Detect new device
        device = self.host_manager.detect_new_device()
        if not device:
            logger.error("No new storage device detected")
            return False
        logger.info(f"Detected new device: {device}")
        
        # Format device
        if not self.host_manager.format_device(device):
            logger.error("Failed to format device")
            return False
        
        # Mount device
        if not self.host_manager.mount_device(device, self.host_manager.config.mount_point):
            logger.error("Failed to mount device")
            return False
        self.operation_status["volume_mounted"] = True
        
        return True
    
    def run_performance_test(self) -> bool:
        """Run performance test"""
        logger.info("Running performance test...")
        
        if self.host_manager.run_performance_test(
            self.host_manager.config.mount_point, 
            self.host_manager.config.test_duration
        ):
            self.operation_status["test_completed"] = True
            logger.info("Performance test completed successfully")
            return True
        else:
            logger.error("Performance test failed")
            return False
    
    def cleanup(self) -> bool:
        """Cleanup resources"""
        logger.info("Cleaning up resources...")
        
        success = True
        
        # Disconnect from SAN
        if not self.san_manager.disconnect():
            logger.warning("Failed to disconnect from SAN")
            success = False
        
        # Disconnect from host
        if not self.host_manager.disconnect():
            logger.warning("Failed to disconnect from host")
            success = False
        
        return success
    
    def get_status_report(self) -> Dict[str, Any]:
        """Get status report of all operations"""
        return {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "operations": self.operation_status,
            "success": all(self.operation_status.values())
        }

def load_config(config_file: str = "config.json") -> Optional[Config]:
    """Load configuration from JSON file"""
    try:
        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                config_data = json.load(f)
                return Config(**config_data)
        else:
            # Return default config if file doesn't exist
            return Config(
                san_ip="10.196.172.88",
                host_ip="10.196.172.90",
                san_username="admin",
                san_password="password",
                host_username="root",
                host_password="password"
            )
    except Exception as e:
        logger.error(f"Failed to load configuration: {e}")
        return None

def save_config(config: Config, config_file: str = "config.json") -> bool:
    """Save configuration to JSON file"""
    try:
        with open(config_file, 'w') as f:
            json.dump(config.__dict__, f, indent=2)
        logger.info(f"Configuration saved to {config_file}")
        return True
    except Exception as e:
        logger.error(f"Failed to save configuration: {e}")
        return False

def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description="SAN Storage Automation Script")
    parser.add_argument("--config", "-c", default="config.json", help="Configuration file path")
    parser.add_argument("--test-only", "-t", action="store_true", help="Run only performance test")
    parser.add_argument("--duration", "-d", type=int, help="Test duration in seconds")
    parser.add_argument("--size", "-s", type=int, help="Volume size in GB")
    
    return parser.parse_args()

def main():
    """Main execution function"""
    args = parse_arguments()
    
    # Load configuration
    config = load_config(args.config)
    if not config:
        logger.error("Failed to load configuration")
        return 1
    
    # Override config with command line arguments
    if args.duration:
        config.test_duration = args.duration
    if args.size:
        config.volume_size_gb = args.size
    
    # Save updated configuration
    save_config(config, args.config)
    
    logger.info("Starting SAN Storage Automation")
    logger.info(f"SAN IP: {config.san_ip}")
    logger.info(f"Host IP: {config.host_ip}")
    logger.info(f"Volume Size: {config.volume_size_gb}GB")
    logger.info(f"Test Duration: {config.test_duration}s")
    
    # Initialize managers (these would be vendor-specific implementations)
    # For now, using base classes - you need to implement vendor-specific subclasses
    san_manager = BaseSanManager(config)
    host_manager = BaseHostManager(config)
    
    # Initialize orchestrator
    orchestrator = SanAutomationOrchestrator(san_manager, host_manager)
    
    try:
        # Initialize connections
        if not orchestrator.initialize_connections():
            return 1
        
        if not args.test_only:
            # Create storage infrastructure
            if not orchestrator.create_storage_infrastructure():
                return 1
            
            # Configure host storage
            if not orchestrator.configure_host_storage():
                return 1
        
        # Run performance test
        if not orchestrator.run_performance_test():
            return 1
        
        # Generate status report
        status = orchestrator.get_status_report()
        logger.info(f"Final Status: {'SUCCESS' if status['success'] else 'FAILED'}")
        logger.info(json.dumps(status, indent=2))
        
        return 0 if status['success'] else 1
        
    except KeyboardInterrupt:
        logger.info("Operation interrupted by user")
        return 1
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return 1
    finally:
        # Cleanup
        orchestrator.cleanup()

if __name__ == "__main__":
    sys.exit(main())
